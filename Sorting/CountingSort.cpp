* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용, 이에 한에서 데이터의 개수가 많더라도 빠르게 동작
* 가장 큰 데이터와 가장 작은 데이터와의 차이가 1,000,000을 넘지 않을 때 효과적
* 때에 따라서 심각한 비효율성 초래 (데이터가 0과 999,999 단 2개만 존재할 때도 배열의 크기가 100만개가 되도록 선언)
* 동일한 데이터가 중복되어 있을 때 적합

* 퀵 정렬보다 빠르다.

계수 정렬(O(n+k), n : 데이터의 개수, k : 데이터 중 최대값의 크기)

#include <bits/stdc++.h>
#define MAX_VALUE 9

using namespace std;

int n = 15;

// 모든 원소의 값이 0보다 크거나 같다고 가정
int arr[15] = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};

// 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)
int cnt[MAX_VALUE + 1];

int main(void) {
    for (int i = 0; i < n; i++) {
        cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가
    }
    for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인
        for (int j = 0; j < cnt[i]; j++) {
            cout << i << ' '; // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력
        }
    }
}

<출력 결과>
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9 
